--- binutils.orig/ld/emultempl/elf32.em	2017-09-14 15:35:45.971100712 +0100
+++ binutils-2.29/ld/emultempl/elf32.em	2017-09-14 15:40:30.315782167 +0100
@@ -2011,6 +2011,29 @@ output_rel_find (asection *sec, int isdy
 
 static int orphan_init_done = 0;
 
+/* Return whether IN is suitable to be part of OUT.  */
+
+static bfd_boolean
+elf_orphan_compatible (asection *in, asection *out)
+{
+  /* Non-zero sh_info implies a section with SHF_INFO_LINK with
+     unknown semantics for the generic linker, or a SHT_REL/SHT_RELA
+     section where sh_info specifies a symbol table.  (We won't see
+     SHT_GROUP, SHT_SYMTAB or SHT_DYNSYM sections here.)  We clearly
+     can't merge SHT_REL/SHT_RELA using differing symbol tables, and
+     shouldn't merge sections with differing unknown semantics.  */
+  if (elf_section_data (out)->this_hdr.sh_info
+      != elf_section_data (in)->this_hdr.sh_info)
+    return FALSE;
+  /* We can't merge two sections with differing SHF_EXCLUDE when doing
+     a relocatable link.  */
+  if (bfd_link_relocatable (&link_info)
+      && ((elf_section_flags (out) ^ elf_section_flags (in)) & SHF_EXCLUDE) != 0)
+    return FALSE;
+  return _bfd_elf_match_sections_by_type (link_info.output_bfd, out,
+					  in->owner, in);
+}
+
 /* Place an orphan section.  We use this to put random SHF_ALLOC
    sections in the right segment.  */
 
@@ -2067,8 +2090,9 @@ gld${EMULATION_NAME}_place_orphan (asect
   lang_output_section_statement_type *os;
   lang_output_section_statement_type *match_by_name = NULL;
   int isdyn = 0;
-  int iself = s->owner->xvec->flavour == bfd_target_elf_flavour;
-  unsigned int sh_type = iself ? elf_section_type (s) : SHT_NULL;
+  int elfinput = s->owner->xvec->flavour == bfd_target_elf_flavour;
+  int elfoutput = link_info.output_bfd->xvec->flavour == bfd_target_elf_flavour;
+  unsigned int sh_type = elfinput ? elf_section_type (s) : SHT_NULL;
   flagword flags;
   asection *nexts;
 
@@ -2076,7 +2100,7 @@ gld${EMULATION_NAME}_place_orphan (asect
       && link_info.combreloc
       && (s->flags & SEC_ALLOC))
     {
-      if (iself)
+      if (elfinput)
 	switch (sh_type)
 	  {
 	  case SHT_RELA:
@@ -2098,6 +2122,8 @@ gld${EMULATION_NAME}_place_orphan (asect
     }
 
   if (!bfd_link_relocatable (&link_info)
+      && elfinput
+      && elfoutput
       && (s->flags & SEC_ALLOC) != 0
       && (elf_section_flags (s) & SHF_GNU_MBIND) != 0)
     {
@@ -2148,23 +2174,18 @@ gld${EMULATION_NAME}_place_orphan (asect
 	   lang_insert_orphan to create a new output section.  */
 	constraint = SPECIAL;
 
-	/* SEC_EXCLUDE is cleared when doing a relocatable link.  But
-	   we can't merge 2 input sections with the same name when only
-	   one of them has SHF_EXCLUDE.  Don't merge 2 sections with
-	   different sh_info.  */
+	/* Check to see if we already have an output section statement
+	   with this name, and its bfd section has compatible flags.
+	   If the section already exists but does not have any flags
+	   set, then it has been created by the linker, possibly as a
+	   result of a --section-start command line switch.  */
 	if (os->bfd_section != NULL
-	    && (elf_section_data (os->bfd_section)->this_hdr.sh_info
-		== elf_section_data (s)->this_hdr.sh_info)
 	    && (os->bfd_section->flags == 0
-		|| ((!bfd_link_relocatable (&link_info)
-		     || (iself && (((elf_section_flags (s)
-				     ^ elf_section_flags (os->bfd_section))
-				    & SHF_EXCLUDE) == 0)))
-		    && ((s->flags ^ os->bfd_section->flags)
+		|| (((s->flags ^ os->bfd_section->flags)
 		     & (SEC_LOAD | SEC_ALLOC)) == 0
-		    && _bfd_elf_match_sections_by_type (link_info.output_bfd,
-							os->bfd_section,
-							s->owner, s))))
+		    && (!elfinput
+			|| !elfoutput
+			|| elf_orphan_compatible (s, os->bfd_section)))))
 	  {
 	    /* We already have an output section statement with this
 	       name, and its bfd section has compatible flags.
@@ -2253,8 +2274,8 @@ gld${EMULATION_NAME}_place_orphan (asect
   else if ((flags & SEC_ALLOC) == 0)
     ;
   else if ((flags & SEC_LOAD) != 0
-	   && ((iself && sh_type == SHT_NOTE)
-	       || (!iself && CONST_STRNEQ (secname, ".note"))))
+	   && ((elfinput && sh_type == SHT_NOTE)
+	       || (!elfinput && CONST_STRNEQ (secname, ".note"))))
     place = &hold[orphan_interp];
   else if ((flags & (SEC_LOAD | SEC_HAS_CONTENTS | SEC_THREAD_LOCAL)) == 0)
     place = &hold[orphan_bss];
@@ -2264,8 +2285,8 @@ gld${EMULATION_NAME}_place_orphan (asect
     place = &hold[orphan_tdata];
   else if ((flags & SEC_READONLY) == 0)
     place = &hold[orphan_data];
-  else if (((iself && (sh_type == SHT_RELA || sh_type == SHT_REL))
-	    || (!iself && CONST_STRNEQ (secname, ".rel")))
+  else if (((elfinput && (sh_type == SHT_RELA || sh_type == SHT_REL))
+	    || (!elfinput && CONST_STRNEQ (secname, ".rel")))
 	   && (flags & SEC_LOAD) != 0)
     place = &hold[orphan_rel];
   else if ((flags & SEC_CODE) == 0)
diff -rup binutils.orig/bfd/elf32-i386.c binutils-2.29/bfd/elf32-i386.c
--- binutils.orig/bfd/elf32-i386.c	2017-09-15 10:27:16.828950825 +0100
+++ binutils-2.29/bfd/elf32-i386.c	2017-09-15 10:27:38.962692771 +0100
@@ -6921,8 +6921,9 @@ elf_i386_link_setup_gnu_properties (stru
       for (abfd = info->input_bfds;
 	   abfd != NULL;
 	   abfd = abfd->link.next)
-	if ((abfd->flags
-	     & (DYNAMIC | BFD_LINKER_CREATED | BFD_PLUGIN)) == 0)
+	if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
+	    && (abfd->flags
+		 & (DYNAMIC | BFD_LINKER_CREATED | BFD_PLUGIN)) == 0)
 	  {
 	    htab->elf.dynobj = abfd;
 	    dynobj = abfd;
diff -rup binutils.orig/bfd/elf64-x86-64.c binutils-2.29/bfd/elf64-x86-64.c
--- binutils.orig/bfd/elf64-x86-64.c	2017-09-15 10:27:16.820950918 +0100
+++ binutils-2.29/bfd/elf64-x86-64.c	2017-09-15 10:28:02.621416935 +0100
@@ -7466,8 +7466,9 @@ error_alignment:
 	  for (abfd = info->input_bfds;
 	       abfd != NULL;
 	       abfd = abfd->link.next)
-	    if ((abfd->flags
-		 & (DYNAMIC | BFD_LINKER_CREATED | BFD_PLUGIN)) == 0)
+	    if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
+		&& (abfd->flags
+		    & (DYNAMIC | BFD_LINKER_CREATED | BFD_PLUGIN)) == 0)
 	      {
 		htab->elf.dynobj = abfd;
 		dynobj = abfd;
